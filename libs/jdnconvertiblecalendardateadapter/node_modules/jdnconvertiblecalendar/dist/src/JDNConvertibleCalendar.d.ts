import { TypeDefinitionsModule } from './TypeDefinitions';
import { CalendarDate } from './CalendarDate';
import { JDNPeriod } from './JDNPeriod';
import { CalendarPeriod } from './CalendarPeriod';
/**
 * Abstract class representing any calendar
 * that can be converted from and to a Julian Day.
 */
export declare abstract class JDNConvertibleCalendar {
    /**
     * Constant for the Gregorian calendar.
     */
    protected static readonly gregorian = "Gregorian";
    /**
     * Constant for the Julian calendar.
     */
    protected static readonly julian = "Julian";
    /**
     * Constant for the Islamic calendar.
     */
    protected static readonly islamic = "Islamic";
    /**
     * Supported calendars (to be extended when new subclasses are implemented).
     */
    static readonly supportedCalendars: string[];
    /**
     * Calendar name of a subclass of `JDNConvertibleCalendar`.
     */
    abstract readonly calendarName: string;
    /**
     * Indicates how many months a year has in a specific calendar.
     */
    abstract readonly monthsInYear: number;
    /**
     * Indicates if the year 0 exists in a specific calendar.
     */
    abstract readonly yearZeroExists: Boolean;
    /**
     * Start of a given date in a specific calendar.
     */
    protected calendarStart: CalendarDate;
    /**
     * End of a given date in a specific calendar.
     */
    protected calendarEnd: CalendarDate;
    /**
     * Indicates if the date is exact (start and end of the given period are equal).
     */
    protected exactDate: Boolean;
    /**
     * Start of given date as JDN.
     */
    protected jdnStart: TypeDefinitionsModule.JDN;
    /**
     * End of given date as JDN.
     */
    protected jdnEnd: TypeDefinitionsModule.JDN;
    /**
     * Converts a given JDN to a calendar date.
     * This method has to be implemented for each subclass
     * (specific calendar).
     *
     * Attention: depending on the conventions used, there may be a year 0 or not.
     * This depends on the implementation of this conversion function.
     *
     * @param jdn JDN to be converted to a calendar date.
     * @returns calendar date created from given JDN.
     */
    protected abstract JDNToCalendar(jdn: TypeDefinitionsModule.JDN): CalendarDate;
    /**
     * Converts a given calendar date to JDN.
     * This method has to be implemented for each subclass
     * (specific calendar).
     *
     * Attention: depending on the conventions used, there may be a year 0 or not.
     * This depends on the implementation of this conversion function.
     *
     * @param date calendar date to be converted to a JDN.
     * @returns JDN created from given calendar date.
     */
    protected abstract calendarToJDN(date: CalendarDate): TypeDefinitionsModule.JDN;
    /**
     * Calculates the day of week of a given JDN.
     *
     * @param jdn JDN for which the day of the week is to be calculated.
     * @returns day of week of the given JDN (as a 0-based index).
     */
    protected abstract dayOfWeekFromJDN(jdn: TypeDefinitionsModule.JDN): number;
    /**
     * Calculates number of days for the month of the given date.
     *
     * The given date is expected to be of the same calendar as the instance the method is called on.
     *
     * @param date given date.
     * @returns number of days in month of given date.
     */
    daysInMonth(date: CalendarDate): number;
    /**
     * Converts the given JDN period to a calendar period and stores it.
     *
     * This method makes sure that JDNs and calendar dates are in sync. This method has no return value,
     * it manipulates `this.calendarStart`, and `this.calendarEnd` instead.
     *
     * Do not manipulate members `this.exactDate`, `this.jdnStart`, `this.jdnEnd`, `this.calendarStart`, and `this.calendarEnd` directly,
     * use this method instead.
     *
     * @param jdnPeriod the period defined by JDNs to be converted to a calendar period.
     */
    protected convertJDNPeriodToCalendarPeriod(jdnPeriod: JDNPeriod): void;
    /**
     * This constructor is inherited by all subclasses (no implementation in subclass required).
     *
     * The constructor supports two signatures:
     * - period: JDNPeriod creates a date from the given `JDNPeriod` (two JDNs)
     * - period: CalendarPeriod creates a date from the given `CalendarPeriod` (two calendar dates)
     */
    constructor(period: JDNPeriod);
    constructor(period: CalendarPeriod);
    /**
     * Returns the given period as two calendar dates.
     *
     * @returns period consisting of two calendar dates.
     */
    toCalendarPeriod(): CalendarPeriod;
    /**
     * Converts an instance of `JDNConvertibleCalendar` to a `JDNPeriod`.
     *
     * @returns period consisting of two JDNs.
     */
    toJDNPeriod(): JDNPeriod;
    /**
     * Converts from one calendar into another.
     *
     * To be extended when new subclasses are added.
     *
     * @param {"Gregorian" | "Julian" | "Islamic"} toCalendarType calendar to convert to.
     * @returns instance of target calendar (subclass of `JDNConvertibleCalendar`).
     */
    convertCalendar(toCalendarType: 'Gregorian' | 'Julian' | 'Islamic'): JDNConvertibleCalendar;
    /**
     * Transposes the current period by the given number of days.
     *
     * @param days the number of days that the current period will be shifted.
     */
    transposePeriodByDay(days: number): void;
    /**
     * Transposes the current period by the given number of years.
     *
     * This method is not accurate in the arithmetical sense: it tries to fit the given day in the month of the new year.
     * If this is not possible, it takes the last day of the new month (e.g., February 29 will become the last possible day of February).
     *
     * @param years the number of years that the current period will be shifted.
     */
    transposePeriodByYear(years: number): void;
    /**
     * Converts the given calendar date to a new one, shifting the months by the given number.
     *
     * @param calendarDate the given calendar date.
     * @param months the number of months to shift.
     * @returns calendar transposed by the given number of months.
     */
    protected handleMonthTransposition(calendarDate: CalendarDate, months: number): CalendarDate;
    /**
     * Transposes the current period by the given number of months.
     *
     * This method is not accurate in the arithmetical sense: it tries to fit the given day in the new month.
     * If this is not possible, it takes the last day of the new month (e.g., January 31 will become the last possible day of February).
     *
     * @param months the number of months that the current period will be shifted.
     */
    transposePeriodByMonth(months: number): void;
}
/**
 * Represents a Gregorian calendar date.
 */
export declare class GregorianCalendarDate extends JDNConvertibleCalendar {
    readonly calendarName = "Gregorian";
    readonly monthsInYear = 12;
    readonly yearZeroExists = true;
    protected JDNToCalendar(jdn: TypeDefinitionsModule.JDN): CalendarDate;
    protected calendarToJDN(date: CalendarDate): TypeDefinitionsModule.JDN;
    protected dayOfWeekFromJDN(jdn: number): number;
}
/**
 * Represents a Julian calendar date.
 */
export declare class JulianCalendarDate extends JDNConvertibleCalendar {
    readonly calendarName = "Julian";
    readonly monthsInYear = 12;
    readonly yearZeroExists = true;
    protected JDNToCalendar(jdn: TypeDefinitionsModule.JDN): CalendarDate;
    protected calendarToJDN(date: CalendarDate): TypeDefinitionsModule.JDN;
    protected dayOfWeekFromJDN(jdn: TypeDefinitionsModule.JDN): number;
}
/**
 * Represents an Islamic calendar date.
 */
export declare class IslamicCalendarDate extends JDNConvertibleCalendar {
    readonly calendarName = "Islamic";
    readonly monthsInYear = 12;
    readonly yearZeroExists = true;
    protected JDNToCalendar(jdn: TypeDefinitionsModule.JDN): CalendarDate;
    protected calendarToJDN(date: CalendarDate): TypeDefinitionsModule.JDN;
    protected dayOfWeekFromJDN(jdn: TypeDefinitionsModule.JDN): number;
}
